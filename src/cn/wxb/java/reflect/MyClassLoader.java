package cn.wxb.java.reflect;


/**
 * 类加载器 - 双亲委托加载机制
 * 1. 类加载器
 *   a. 系统类加载起： bootstrapClassloader - 启动类加载器，用来加载jvm运行时所需要的系统类，由c++实现
 *                  ExtensionsClassloader - 扩展类加载器，由ExtClassLoader类实现
 *                  AppClassloader - 系统类加载器， 由AppClassLoader类实现
 *
 *   b. 自定义类加载起
 *
 * 2. 双亲委托机制
 *   a. 首先判断class是否已加载
 *   b. 如果没有则不是自身去查找而是委托给父加载器进行查找，这样依次的进行递归，直到委托到最顶层的Bootstrap ClassLoader
 *   c. 如果Bootstrap ClassLoader找到了该Class，就会直接返回
 *   d. 如果没找到，则继续依次向下查找，如果还没找到则最后会交由子类去查找
 *
 * 3. 双亲委托机制好处
 *   a. 因为这样可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子ClassLoader再加载一次。
 *   b. 考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的String来动态替代java核心api中定义类型，
 *      这样会存在非常大的安全隐患，而双亲委托的方式，就可以避免这种情况，因为String已经在启动时被加载，
 *      所以用户自定义类是无法加载一个自定义的ClassLoader
 *
 *  4. JVM内存模型，主要分为程序计数器，栈，堆，方法区和本地方法区。
 *      a. 程序计数器（PC寄存器） - 线程私有的，唯一没有outOfMemoryError的区域，
 *                      字节码解释器的工作就是通过改变程序计数器来选取下一条需要执行的字节码指令
 *      b. Java虚拟机栈 - 一个Java虚拟机栈包括多个栈帧，一个栈帧用来存储局部变量表、操作数栈、动态链接、方法出口等信息。
 *          当线程调用一个Java方法的时候，虚拟机压入一个新的栈帧到该线程的Java虚拟机栈中，当该方法执行完成后，
 *          这个栈帧就从java虚拟机栈中弹出。
 *      c. 本地方法栈 - 用来支持Native方法的
 *      d. java堆 - 是被所有线程共享的运行时内存区域。Java堆用来存放对象实例，几乎所有的对象实例都会在这里分配内存
 *      e. 方法区 - 是被所有线程共享的运行时内存区域。用来存储已经被Java虚拟机加载的类的结构信息，
 *              包括运行时常量池、字段、方法信息、静态变量等数据。
 *
 *  5. ART与DVM的区别
 *      a. DVM中的应用每次运行时，字节码都需要通过JIT编译器编译为机器码，这样会使应用程序的运行效率降低。
 *          而在ART中，系统安装应用程序时会进行一次AOT（ahead of time compilation），将字节码预编译成机器码并存储在本地，
 *          这样应用程序每次运行时就不需要执行编译了，会大大增加效率。
 *      b. DVM是为32位CPU设计的，而ART是支持64位并且兼容32位CPU，这也是DVM被淘汰的主要原因之一。
 *      c. ART对垃圾回收机制进行了改进，比如更频繁的执行并行垃圾收集，将GC暂停由2次减少为1次等等
 *      d. ART运行时堆空间划分和DVM不同。
 *      e. DVM的垃圾回收算法采用的是标记-清除算法
 *          ART改进了该算法，并且使用了多种垃圾收集器。
 *
 */
public class MyClassLoader extends ClassLoader{


    private String name;

}
